"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[3084],{17565:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"dev/incremental-commits-and-decommits","title":"Incremental commits and decommits","description":"These two new addons to the initial Hydra Head protocol deserve more","source":"@site/docs/dev/incremental-commits-and-decommits.md","sourceDirName":"dev","slug":"/dev/incremental-commits-and-decommits","permalink":"/head-protocol/unstable/docs/dev/incremental-commits-and-decommits","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/docs/dev/incremental-commits-and-decommits.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerDocumentation","previous":{"title":"Protocol","permalink":"/head-protocol/unstable/docs/dev/protocol"},"next":{"title":"Commit funds to a Head","permalink":"/head-protocol/unstable/docs/dev/commit_to_a_Head"}}');var s=t(74848),o=t(28453);const a={},c="Incremental commits and decommits",d={},r=[{value:"Incremental Commits",id:"incremental-commits",level:2},{value:"Incremental Decommits",id:"incremental-decommits",level:2}];function l(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"incremental-commits-and-decommits",children:"Incremental commits and decommits"})}),"\n",(0,s.jsxs)(n.p,{children:["These two new addons to the initial Hydra Head protocol deserve more\nexplanation so our users are aware of how they work ",(0,s.jsx)(n.em,{children:"under the hood"})," to bring\nmore clarity to these processes."]}),"\n",(0,s.jsx)(n.p,{children:"For now these two new additions run sequentially so we are doing one thing at a\ntime, at least for now, while we will think about batching certain actions in\nthe future if the need for that arises."}),"\n",(0,s.jsx)(n.p,{children:"It is only possible to either commit or decommit - we don't allow snapshots with both\nfields specified for simplicity. This restriction might be lifted later on - once we\nare sure this simpler version works nicely."}),"\n",(0,s.jsx)(n.h2,{id:"incremental-commits",children:"Incremental Commits"}),"\n",(0,s.jsxs)(n.p,{children:["Incremental Commits allow us to take some ",(0,s.jsx)(n.code,{children:"UTxO"})," from L1 and make it available\non L2 for transacting inside of a running Hydra Head."]}),"\n",(0,s.jsxs)(n.p,{children:["The process for incremental commits is pretty much the same as when\n",(0,s.jsx)(n.em,{children:"committing"})," before the Head is in the ",(0,s.jsx)(n.code,{children:"Open"})," state. In fact we can open a Head\nwithout committing some funds and then ",(0,s.jsx)(n.em,{children:"top-up"})," our L2 funds by doing incremental\ncommits."]}),"\n",(0,s.jsxs)(n.p,{children:["The process of incrementally committing a ",(0,s.jsx)(n.code,{children:"UTxO"})," starts by sending a ",(0,s.jsx)(n.code,{children:"HTTP"})," request to\nthe hydra-node API endpoint:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\ncurl -X POST <IP>:<PORT>/commit --data @commit.json\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Note that the commit transaction, which is sent to the hydra-node API, only needs\nto specify the transaction inputs present in L1 that we want to make available\non L2. It will ignore any specified outputs and instead the owner of\nincremented ",(0,s.jsx)(n.code,{children:"UTxO"})," on L2 is the same one that owned the funds on L1."]})}),"\n",(0,s.jsxs)(n.p,{children:["Hydra node will accept a plain ",(0,s.jsx)(n.code,{children:"UTxO"})," encoded as JSON in the ",(0,s.jsx)(n.code,{children:"POST"})," request\nbody or a ",(0,s.jsx)(n.em,{children:"blueprint"})," transaction together with the ",(0,s.jsx)(n.code,{children:"UTxO"})," used to resolve it's\ninputs."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Blueprint"})," transaction is just like a recipe that describes which transaction\ninputs should be made available on L2 network ignoring any specified outputs.\nIt goes together with a ",(0,s.jsx)(n.code,{children:"UTxO"})," used to resolve the transaction inputs. It's\npurpose is to prove that one can spend specified transaction inputs."]}),"\n",(0,s.jsxs)(n.p,{children:["Successfull API response includes a ",(0,s.jsx)(n.em,{children:"deposit"})," transaction that needs to be\nsigned and submitted by the user in order to kick-off the deposit process."]}),"\n",(0,s.jsxs)(n.p,{children:["This process just locks the specified ",(0,s.jsx)(n.code,{children:"UTxO"})," at a deposit script address which\nwill then, later on, after confirmed snapshot, be unlocked by the ",(0,s.jsx)(n.em,{children:"increment"}),"\ntransaction which will actually make this ",(0,s.jsx)(n.code,{children:"UTxO"})," available on L2."]}),"\n",(0,s.jsxs)(n.p,{children:["The deposit transaction contains a deadline - time window in which we expect\nthe hydra-node to be able to observe this deposit and issue a ",(0,s.jsx)(n.em,{children:"increment"}),"\ntransaction that will do the heavy lifting and bring the specified input on L2."]}),"\n",(0,s.jsxs)(n.p,{children:["Currently, ",(0,s.jsx)(n.em,{children:"contestation period"})," value is used to specify a deposit deadline\nbut this should be made available as a separate argument to hydra-node since it\nheavily depends on the network we are running on."]}),"\n",(0,s.jsx)(n.p,{children:"Once a hydra-node observes a deposit transaction it will record the deposit as\npending into the local state. There can be many pending deposits but the new\nSnapshot will include them one by one."}),"\n",(0,s.jsxs)(n.p,{children:["When this new Snapshot is acknowledged by all parties ",(0,s.jsx)(n.em,{children:"increment"})," transaction\nwill be posted by the leader."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Note that any node that posts increment transaction will also pay the fees even if\nthe deposit will not be owned by them on L2."})}),"\n",(0,s.jsx)(n.p,{children:"Upon observing increment transaction we remove deposit from the local pending deposits\nand the process can start again."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Since we can potentially request many deposits, the leader will increment only\none of them. While others are stuck in the pending state any new transaction on\nL2 will take next pending deposit and try to include it in a snapshot."})}),"\n",(0,s.jsx)(n.h2,{id:"incremental-decommits",children:"Incremental Decommits"}),"\n",(0,s.jsxs)(n.p,{children:["Incremental decommits allow us to take some L2 ",(0,s.jsx)(n.code,{children:"UTxO"})," and bring it to the L1\nwhile the Head protocol is running."]}),"\n",(0,s.jsxs)(n.p,{children:["Head participant (or any other user that can send requests to the hydra-node\nAPI endpoint) requests inclusion of some UTxO from L1 by sending a ",(0,s.jsx)(n.code,{children:"POST"}),"\n",(0,s.jsx)(n.code,{children:"HTTP"})," request which contains in the request body a decommit transaction\nencoded as ",(0,s.jsx)(n.em,{children:"TextEnvelope"})," JSON value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"curl -X POST <IP>:<PORT>/decommit --data @decommit-tx.json\n"})}),"\n",(0,s.jsx)(n.p,{children:"This transaction needs to be signed by the owner of the funds on L2."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"What we call a decommit transaction is the one that user supplies in the API\nendpoint. The decrement transaction is the transaction that hydra-node posts\nafter it checks that decommit transaction applies and the one that actually\nmakes some UTxO available on L1."})}),"\n",(0,s.jsxs)(n.p,{children:["Hydra node accepts this transaction and checks if it can be cleanly applied to\nthe local ",(0,s.jsx)(n.code,{children:"UTxO"})," set. After this check hydra-node will issue a ",(0,s.jsx)(n.code,{children:"ReqDec"})," message\nsignalling to other parties that we want to produce a new ",(0,s.jsx)(n.code,{children:"Snapshot"})," that\ncontains the same  ",(0,s.jsx)(n.code,{children:"UTxO"})," to decommit. Once a snapshot is signed, hydra-node\nposts a ",(0,s.jsx)(n.em,{children:"decrement"})," transaction that will take specified output and make it\navailable on L1."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);