"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[4001],{73238:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"dev/architecture/networking","title":"Networking","description":"This page provides details about the Hydra networking layer, through which hydra","source":"@site/docs/dev/architecture/networking.md","sourceDirName":"dev/architecture","slug":"/dev/architecture/networking","permalink":"/head-protocol/unstable/docs/dev/architecture/networking","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/docs/dev/architecture/networking.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerDocumentation","previous":{"title":"Architecture","permalink":"/head-protocol/unstable/docs/dev/architecture/"},"next":{"title":"Handling rollbacks","permalink":"/head-protocol/unstable/docs/dev/rollbacks/"}}');var i=s(74848),o=s(28453);const r={},a="Networking",l={},c=[{value:"Interface",id:"interface",level:2},{value:"Topology",id:"topology",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Fault model",id:"fault-model",level:2},{value:"Implementations",id:"implementations",level:2},{value:"Current network stack",id:"current-network-stack",level:3},{value:"Gossip diffusion network",id:"gossip-diffusion-network",level:3},{value:"Network resilience testing",id:"network-resilience-testing",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"networking",children:"Networking"})}),"\n",(0,i.jsxs)(n.p,{children:["This page provides details about the Hydra networking layer, through which hydra\nnodes exchange off-chain protocol messages. The off-chain protocol relies\nheavily on the correct operation of the ",(0,i.jsx)(n.strong,{children:"multicast"})," abstraction (",(0,i.jsx)(n.code,{children:"broadcast"}),"\nin our fully connected topology here) in the way ",(0,i.jsx)(n.a,{href:"../specification",children:"it is\nspecified"})," and the following sections explain our realization\nin the Hydra node implementation."]}),"\n",(0,i.jsx)(n.h2,{id:"interface",children:"Interface"}),"\n",(0,i.jsxs)(n.p,{children:["Within a ",(0,i.jsx)(n.code,{children:"hydra-node"}),", a ",(0,i.jsx)(n.code,{children:"Network"})," component provides the capability to reliably\n",(0,i.jsx)(n.code,{children:"broadcast"})," a message to the whole Hydra network. In turn, when a message is\nreceived from the network, the ",(0,i.jsx)(n.code,{children:"NetworkCallback"})," signals this by invoking\n",(0,i.jsx)(n.code,{children:"deliver"}),". This interface follows reliable broadcast terminology of distributed\nsystems literature."]}),"\n",(0,i.jsxs)(n.p,{children:["Given the way the ",(0,i.jsx)(n.a,{href:"../specification",children:"off-chain protocol is specified"}),", the\n",(0,i.jsx)(n.code,{children:"broadcast"})," abstraction required from the ",(0,i.jsx)(n.code,{children:"Network"})," interface is a so-called\n",(0,i.jsx)(n.em,{children:"uniform reliable broadcast"})," with properties:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validity"}),": If a correct process p broadcasts a message m, then p eventually delivers m."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No duplication"}),": No message is delivered more than once."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No creation"}),": If a process delivers a message m with sender s, then m was\npreviously broadcast by process s."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Agreement"}),": If a message m is delivered by some correct process, then m is\neventually delivered by every correct process."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["See also Module 3.3 in ",(0,i.jsx)(n.a,{href:"https://www.distributedprogramming.net",children:"Introduction to Reliable and Secure Distributed\nProgramming"})," by Cachin et al, or\n",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2001.03244",children:"Self-stabilizing Uniform Reliable Broadcast by Oskar\nLundstr\xf6m"}),"; or ",(0,i.jsx)(n.a,{href:"https://en.m.wikipedia.org/wiki/Atomic_broadcast",children:"atomic\nbroadcast"})," for an even\nstronger abstraction."]}),"\n",(0,i.jsx)(n.h2,{id:"topology",children:"Topology"}),"\n",(0,i.jsxs)(n.p,{children:["Currently, the ",(0,i.jsx)(n.code,{children:"hydra-node"})," operates in a static, ",(0,i.jsx)(n.strong,{children:"fully connected"})," network\ntopology where each nodes connects to each other node and a message is broadcast\nto all nodes. For this, we need to pass publicly reachable endpoints of ",(0,i.jsx)(n.em,{children:"all\nother nodes"})," via ",(0,i.jsx)(n.code,{children:"--peer"})," options to each hydra node and ",(0,i.jsx)(n.em,{children:"all links"})," must be\noperational to achieve liveness."]}),"\n",(0,i.jsxs)(n.p,{children:["Alternative implementations of a the ",(0,i.jsx)(n.code,{children:"Network"})," interface could improve upon this\nby enabling ",(0,i.jsx)(n.strong,{children:"mesh"})," topologies where messages are forwarded across links. This\nwould simplify configuration to only need to provide ",(0,i.jsx)(n.em,{children:"at least one"})," ",(0,i.jsx)(n.code,{children:"--peer"}),",\nwhile ",(0,i.jsx)(n.em,{children:"peer sharing"})," in such a network could still allow for redundant\nconnections and better fault tolerance."]}),"\n",(0,i.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsxs)(n.p,{children:["The messages exchanged through the ",(0,i.jsx)(n.em,{children:"Hydra networking"})," layer between participants\nare authenticated. Each message is\n",(0,i.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/issues/727",children:"signed"})," using the Hydra\nsigning key of the emitting party, which is identified by the corresponding\nverification key. When a message with an unknown or incorrect signature is\nreceived, it is dropped, and a notification is logged."]}),"\n",(0,i.jsx)(n.p,{children:"Currently, messages are not encrypted. If confidentiality is required, an\nexternal mechanism must be implemented to prevent other parties from observing\nthe messages exchanged within a head."}),"\n",(0,i.jsx)(n.h2,{id:"fault-model",children:"Fault model"}),"\n",(0,i.jsxs)(n.p,{children:["Although the Hydra protocol can only progress when nodes of all participants are\nonline and responsive, the network layer should still provide a certain level of\ntolerance to crashes, transient connection problems and ",(0,i.jsx)(n.em,{children:"non-byzantine"})," faults."]}),"\n",(0,i.jsxs)(n.p,{children:["Concretely, this means that a ",(0,i.jsx)(n.em,{children:"fail-recovery"})," distributed systems model (again see Cachin et al) seems to fit these requirements best. This means, that processes may crash and later recover should still be able to participate in the protocol. Processes may forget what they did prior to crashing, but may use stable storage to persist knowledge. Links may fail and are ",(0,i.jsx)(n.em,{children:"fair-loss"}),", where techniques to improve them to ",(0,i.jsx)(n.em,{children:"stubborn"})," or ",(0,i.jsx)(n.em,{children:"perfect"})," links likely will be required."]}),"\n",(0,i.jsxs)(n.p,{children:["See also ",(0,i.jsx)(n.a,{href:"/adr/27",children:"this ADR"})," for a past discussion on making the network component resilient against faults."]}),"\n",(0,i.jsx)(n.h2,{id:"implementations",children:"Implementations"}),"\n",(0,i.jsx)(n.h3,{id:"current-network-stack",children:"Current network stack"}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"pathname:///haddock/hydra-node/Hydra-Node-Network.html",children:"haddocks"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Hydra nodes form a network of pairwise connected ",(0,i.jsx)(n.em,{children:"peers"})," using point-to-point (eg, TCP) connections that are expected to remain active at all times:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Nodes use ",(0,i.jsx)(n.a,{href:"https://github.com/input-output-hk/ouroboros-network/",children:"Ouroboros"})," as the underlying network abstraction, which manages connections with peers via a reliable point-to-point stream-based communication framework known as a ",(0,i.jsx)(n.code,{children:"Snocket"})]}),"\n",(0,i.jsxs)(n.li,{children:["All messages are ",(0,i.jsx)(n.em,{children:"broadcast"})," to peers using the PTP connections"]}),"\n",(0,i.jsx)(n.li,{children:"Due to the nature of the Hydra protocol, the lack of a connection to a peer halts any progress of the head."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["A ",(0,i.jsx)(n.code,{children:"hydra-node"})," can only open a head with ",(0,i.jsx)(n.em,{children:"all"})," its peers and exclusively with them. This necessitates that nodes possess prior knowledge of the topology of both peers and heads they intend to establish."]}),"\n",(0,i.jsxs)(n.li,{children:["Connected nodes implement basic ",(0,i.jsx)(n.em,{children:"failure detection"})," through heartbeats and monitoring exchanged messages."]}),"\n",(0,i.jsx)(n.li,{children:"Messages exchanged between peers are signed using the party's Hydra key and validated upon receiving."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"gossip-diffusion-network",children:"Gossip diffusion network"}),"\n",(0,i.jsx)(n.p,{children:"The following diagram illustrates one possible implementation of a pull-based messaging system for Hydra, developed from discussions with IOG\u2019s networking engineers:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Hydra pull-based network",src:s(76431).A+"",width:"5827",height:"2745"})}),"\n",(0,i.jsx)(n.h2,{id:"network-resilience-testing",children:"Network resilience testing"}),"\n",(0,i.jsxs)(n.p,{children:["In August 2024 we added some network resilience tests, implemented as a GitHub\naction step in ",(0,i.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/blob/master/.github/workflows/network-test.yaml",children:"network-test.yaml"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The approach is to use ",(0,i.jsx)(n.a,{href:"https://github.com/alexei-led/pumba",children:"Pumba"})," to inject\nnetworking faults into a docker-based setup. This is effective, because of the\n",(0,i.jsx)(n.a,{href:"https://srtlab.github.io/srt-cookbook/how-to-articles/using-netem-to-emulate-networks.html",children:"NetEm"}),"\ncapability that allows for very powerful manipulation of the networking stack\nof the containers."]}),"\n",(0,i.jsxs)(n.p,{children:["Initially, we have set up percentage-based loss on some very specific\nscenarios; namely a three-node setup between ",(0,i.jsx)(n.code,{children:"Alice"}),", ",(0,i.jsx)(n.code,{children:"Bob"})," and ",(0,i.jsx)(n.code,{children:"Carol"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"With this setup, we tested the following scenarios:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'Three nodes, 900 transactions ("scaling=10"):'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"2% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"3% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"4% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"5% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(n.li,{children:"10% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(n.li,{children:"20% packet loss to both peers: \u274cFailure"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'Three nodes, 4500 transactions ("scaling=50"):'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"2% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"3% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(n.li,{children:"4% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(n.li,{children:"5% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(n.li,{children:"10% packet loss to both peers: \u274cFailure"}),"\n",(0,i.jsx)(n.li,{children:"20% packet loss to both peers: \u274cFailure"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:['"Success" here means that ',(0,i.jsx)(n.em,{children:"all"}),' transactions were processed; "Failure" means\none or more transactions did not get confirmed by all participants within a\nparticular timeframe.']}),"\n",(0,i.jsxs)(n.p,{children:["The main conclusion here is ... there's a limit to the amount of packet loss\nwe can sustain, it's related to how many transactions we are trying to send\n(naturally, ",(0,i.jsx)(n.a,{href:"http://www.voiptroubleshooter.com/indepth/burstloss.html",children:"given the percent of failure is per\npacket"}),".)"]}),"\n",(0,i.jsxs)(n.p,{children:["You can keep an eye on the runs of this action here: ",(0,i.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/actions/workflows/network-test.yaml",children:"Network fault\ntolerance"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The main things to note are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Overall, the CI job will succeed even if every scenario fails. This is,\nultimately, due to a bug in ",(0,i.jsx)(n.a,{href:"https://github.com/actions/runner/issues/2347",children:"GitHub\nactions"})," that prevents one\nfrom declaring an explicit pass-or-fail expectation per scenario. The impact\nis that you should manually check this job on each of your PRs."]}),"\n",(0,i.jsxs)(n.li,{children:["It's okay to see certain configurations fail, but it's certainly not\nexpected to see them ",(0,i.jsx)(n.em,{children:"all"})," fail; certainly not the zero-loss cases. Anything\nthat looks suspcisious should be investigated."]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},76431:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/hydra-pull-based-network-82c3d214f8e8d9b2054a23a4fadd48db.jpg"},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(96540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);