-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hydra Plutus Contracts
--   
--   Hydra Plutus Contracts
@package hydra-plutus
@version 0.19.0


-- | Error codes to be used in plutus scripts.
--   
--   Define a new type and instantiate <a>ToErrorCode</a> for error cases
--   you want to use in scripts.
--   
--   <pre>
--   data MyError = CaseA | CaseB deriving Show
--   
--   instance ToErrorCode MyError where
--     toErrorCode = case
--       CaseA -&gt; <a>CA</a>
--       CaseB -&gt; <a>CB</a>
--   </pre>
--   
--   In plutus-tx, you can then use template haskell to inline the error
--   codes using the '$(errorCode ..)' splice.
--   
--   <pre>
--   validator = traceError $(errorCode CaseA)
--   </pre>
--   
--   This example will have your validator fail with user error <a>CA</a>,
--   which you can match for using 'toErrorCode CaseA' in Haskell.
module Hydra.Contract.Error

-- | Types which are used to describe errors as short error codes in
--   scripts.
class ToErrorCode a

-- | Get the short error code used in a script for given type.
toErrorCode :: ToErrorCode a => a -> Text

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp

module Hydra.Contract.DepositError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data DepositError
DepositDeadlineSurpassed :: DepositError
DepositNoUpperBoundDefined :: DepositError
DepositNoLowerBoundDefined :: DepositError
DepositDeadlineNotReached :: DepositError
IncorrectDepositHash :: DepositError
DTNotMinted :: DepositError
instance GHC.Show.Show Hydra.Contract.DepositError.DepositError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.DepositError.DepositError

module Hydra.Contract.CommitError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data CommitError
STNotBurnedError :: CommitError
STIsMissingInTheOutput :: CommitError
instance GHC.Show.Show Hydra.Contract.CommitError.CommitError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.CommitError.CommitError


-- | An experimental validator which simply hashes a bytestring stored in
--   the datum using one of three supported algorithms.
module Hydra.Contract.Hash
data HashAlgorithm
Base :: HashAlgorithm
SHA2 :: HashAlgorithm
SHA3 :: HashAlgorithm
Blake2b :: HashAlgorithm
type DatumType = BuiltinByteString
type RedeemerType = HashAlgorithm
validator :: DatumType -> RedeemerType -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Hash.HashAlgorithm
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Hash.HashAlgorithm
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Hash.HashAlgorithm
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Contract.Hash.HashAlgorithm
instance GHC.Enum.Bounded Hydra.Contract.Hash.HashAlgorithm
instance GHC.Enum.Enum Hydra.Contract.Hash.HashAlgorithm
instance GHC.Generics.Generic Hydra.Contract.Hash.HashAlgorithm
instance GHC.Show.Show Hydra.Contract.Hash.HashAlgorithm

module Hydra.Contract.HeadError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data HeadError
InvalidHeadStateTransition :: HeadError
ChangedParameters :: HeadError
WrongStateInOutputDatum :: HeadError
HeadValueIsNotPreserved :: HeadError
SignerIsNotAParticipant :: HeadError
NoSigners :: HeadError
TooManySigners :: HeadError
ScriptNotSpendingAHeadInput :: HeadError
NoOutputDatumError :: HeadError
UnexpectedNonInlineDatum :: HeadError
NotPayingToHead :: HeadError
SignatureVerificationFailed :: HeadError
MustNotChangeVersion :: HeadError
BurntTokenNumberMismatch :: HeadError
ReimbursedOutputsDontMatch :: HeadError
STNotSpent :: HeadError
IncorrectUtxoHash :: HeadError
MissingCommits :: HeadError
NotAllValueCollected :: HeadError
IncorrectVersion :: HeadError
VersionNotIncremented :: HeadError
HasBoundedValidityCheckFailed :: HeadError
IncorrectClosedContestationDeadline :: HeadError
InfiniteUpperBound :: HeadError
InfiniteLowerBound :: HeadError
ContestersNonEmpty :: HeadError
CloseNoUpperBoundDefined :: HeadError
FailedCloseInitial :: HeadError
FailedCloseCurrent :: HeadError
FailedCloseOutdated :: HeadError
TooOldSnapshot :: HeadError
UpperBoundBeyondContestationDeadline :: HeadError
ContestNoUpperBoundDefined :: HeadError
MustNotPushDeadline :: HeadError
MustPushDeadline :: HeadError
ContesterNotIncluded :: HeadError
WrongNumberOfSigners :: HeadError
SignerAlreadyContested :: HeadError
FailedContestCurrent :: HeadError
FailedContestOutdated :: HeadError
FanoutUTxOHashMismatch :: HeadError
LowerBoundBeforeContestationDeadline :: HeadError
FanoutNoLowerBoundDefined :: HeadError
FanoutUTxOToDecommitHashMismatch :: HeadError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.HeadError.HeadError

module Hydra.Contract.HeadTokensError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data HeadTokensError
SeedNotSpent :: HeadTokensError
WrongNumberOfTokensMinted :: HeadTokensError
MissingST :: HeadTokensError
WrongNumberOfInitialOutputs :: HeadTokensError
WrongDatum :: HeadTokensError
MintingNotAllowed :: HeadTokensError
NoPT :: HeadTokensError
WrongQuantity :: HeadTokensError
ExpectedHeadDatumType :: HeadTokensError
ExpectedInlineDatum :: HeadTokensError
MultipleHeadOutput :: HeadTokensError
WrongInitialDatum :: HeadTokensError
instance GHC.Show.Show Hydra.Contract.HeadTokensError.HeadTokensError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.HeadTokensError.HeadTokensError

module Hydra.Contract.InitialError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data InitialError
STNotBurned :: InitialError
MissingOrInvalidCommitAuthor :: InitialError
LockedValueDoesNotMatch :: InitialError
MismatchCommittedTxOutInDatum :: InitialError
CouldNotFindTheCorrectCurrencySymbolInTokens :: InitialError
MultipleHeadTokensOrMoreThan1PTsFound :: InitialError
MissingCommittedTxOutInOutputDatum :: InitialError
CommittedTxOutMissingInOutputDatum :: InitialError
MissingDatum :: InitialError
UnexpectedNonInlineDatum :: InitialError
ExpectedCommitDatumTypeGotSomethingElse :: InitialError
ExpectedSingleCommitOutput :: InitialError
WrongHeadIdInCommitDatum :: InitialError
MintingOrBurningIsForbidden :: InitialError
OutRefNotFound :: InitialError
instance GHC.Show.Show Hydra.Contract.InitialError.InitialError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.InitialError.InitialError


-- | Data type used in <a>HeadTokens</a> as a separate module because of
--   TemplateHaskell stage restriction.
module Hydra.Contract.MintAction
data MintAction
Mint :: MintAction
Burn :: MintAction
instance PlutusTx.IsData.Class.ToData Hydra.Contract.MintAction.MintAction
instance PlutusTx.IsData.Class.FromData Hydra.Contract.MintAction.MintAction
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.MintAction.MintAction

module Hydra.Data.ContestationPeriod
newtype ContestationPeriod
UnsafeContestationPeriod :: DiffMilliSeconds -> ContestationPeriod
[milliseconds] :: ContestationPeriod -> DiffMilliSeconds
contestationPeriodFromDiffTime :: NominalDiffTime -> ContestationPeriod
contestationPeriodToDiffTime :: ContestationPeriod -> NominalDiffTime

-- | Compute the (on-chain) contestation deadline from a given current time
--   and the <a>ContestationPeriod</a>.
addContestationPeriod :: POSIXTime -> ContestationPeriod -> POSIXTime
instance PlutusTx.IsData.Class.ToData Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.IsData.Class.FromData Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.ContestationPeriod.ContestationPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Data.ContestationPeriod.ContestationPeriod
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Data.ContestationPeriod.ContestationPeriod
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.Eq.Eq Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Num.Num Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Show.Show Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Ord Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Eq Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Generics.Generic Hydra.Data.ContestationPeriod.ContestationPeriod

module Hydra.Data.Party

-- | On-chain representation of a Hydra party.
--   
--   NOTE: This roughly corresponds to the <a>Party</a> in 'hydra-node',
--   but is simplified to allow usage of this type in plutus-tx. If we
--   would use the complex type directly, which is based on
--   'cardano-crypto-class', we would get errors like "Error: Unsupported
--   feature: Kind: GHC.Types.Nat".
--   
--   The data constructor should not be used to construct this value as it
--   would always come from off-chain code via
--   <a>partyFromVerificationKeyBytes</a>.
newtype Party
UnsafeParty :: BuiltinByteString -> Party
[vkey] :: Party -> BuiltinByteString

-- | Create an on-chain <a>Party</a> from some verification key bytes.
partyFromVerificationKeyBytes :: ByteString -> Party

-- | Get the verification key bytes contained from an on-chain
--   <a>Party</a>.
partyToVerficationKeyBytes :: Party -> ByteString
instance PlutusTx.Eq.Eq Hydra.Data.Party.Party
instance GHC.Show.Show Hydra.Data.Party.Party
instance GHC.Generics.Generic Hydra.Data.Party.Party
instance GHC.Classes.Eq Hydra.Data.Party.Party
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.ToData Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.FromData Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.Party.Party
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Data.Party.Party
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Data.Party.Party

module Hydra.Contract.Util
hydraHeadV1 :: BuiltinByteString

-- | Checks that the output contains the state token (ST) with the head
--   <a>CurrencySymbol</a> and <a>TokenName</a> of <a>hydraHeadV1</a>
hasST :: CurrencySymbol -> Value -> Bool

-- | Checks all tokens related to some specific <a>CurrencySymbol</a>.
--   
--   This checks both PTs and ST are burnt.
mustBurnAllHeadTokens :: Value -> CurrencySymbol -> [Party] -> Bool

-- | Checks if the state token (ST) for list of parties containing specific
--   <a>CurrencySymbol</a> are burnt.
mustBurnST :: Value -> CurrencySymbol -> Bool
mustNotMintOrBurn :: TxInfo -> Bool

-- | Checks for exact equality between two serialized values. Equality on
--   value is very memory intensive as it's defined on associative lists
--   and <tt>AssocMap</tt> equality is implemented. Instead we can be more
--   strict and require EXACTLY the same value and compare using the
--   serialised bytes.
(===) :: Value -> Value -> Bool
infix 4 ===
data UtilError
MintingOrBurningIsForbidden :: UtilError
instance GHC.Show.Show Hydra.Contract.Util.UtilError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.Util.UtilError

module Hydra.Contract.HeadState
type SnapshotNumber = Integer
type SnapshotVersion = Integer
type Hash = BuiltinByteString
type Signature = BuiltinByteString

-- | Sub-type for the open state-machine state.
data OpenDatum
OpenDatum :: CurrencySymbol -> [Party] -> ContestationPeriod -> SnapshotVersion -> Hash -> OpenDatum

-- | Spec: cid
[$sel:headId:OpenDatum] :: OpenDatum -> CurrencySymbol

-- | Spec: kH
[$sel:parties:OpenDatum] :: OpenDatum -> [Party]

-- | Spec: T
[$sel:contestationPeriod:OpenDatum] :: OpenDatum -> ContestationPeriod

-- | Spec: v
[$sel:version:OpenDatum] :: OpenDatum -> SnapshotVersion

-- | Spec: η
[$sel:utxoHash:OpenDatum] :: OpenDatum -> Hash

-- | Sub-type for the closed state-machine state.
data ClosedDatum
ClosedDatum :: CurrencySymbol -> [Party] -> ContestationPeriod -> SnapshotVersion -> SnapshotNumber -> Hash -> Hash -> [PubKeyHash] -> POSIXTime -> ClosedDatum

-- | Spec: cid
[$sel:headId:ClosedDatum] :: ClosedDatum -> CurrencySymbol

-- | Spec: kH
[$sel:parties:ClosedDatum] :: ClosedDatum -> [Party]

-- | Spec: T
[$sel:contestationPeriod:ClosedDatum] :: ClosedDatum -> ContestationPeriod

-- | Spec: v
[$sel:version:ClosedDatum] :: ClosedDatum -> SnapshotVersion

-- | Spec: s
[$sel:snapshotNumber:ClosedDatum] :: ClosedDatum -> SnapshotNumber

-- | Spec: η. Digest of snapshotted UTxO
[$sel:utxoHash:ClosedDatum] :: ClosedDatum -> Hash

-- | Spec: ηΔ. Digest of UTxO still to be distributed
[$sel:deltaUTxOHash:ClosedDatum] :: ClosedDatum -> Hash

-- | Spec: C
[$sel:contesters:ClosedDatum] :: ClosedDatum -> [PubKeyHash]

-- | Spec: tfinal
[$sel:contestationDeadline:ClosedDatum] :: ClosedDatum -> POSIXTime
data State
Initial :: ContestationPeriod -> [Party] -> CurrencySymbol -> TxOutRef -> State
[$sel:contestationPeriod:Initial] :: State -> ContestationPeriod
[$sel:parties:Initial] :: State -> [Party]
[$sel:headId:Initial] :: State -> CurrencySymbol
[$sel:seed:Initial] :: State -> TxOutRef
Open :: OpenDatum -> State
Closed :: ClosedDatum -> State
Final :: State

-- | Sub-type for close transition with auxiliary data as needed.
data CloseRedeemer

-- | Intial snapshot is used to close.
CloseInitial :: CloseRedeemer

-- | Closing snapshot refers to the current state version
CloseUnused :: [Signature] -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | Closing snapshot refers to the previous state version
CloseUsed :: [Signature] -> Hash -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | UTxO which was already decommitted ηω
[$sel:alreadyDecommittedUTxOHash:CloseInitial] :: CloseRedeemer -> Hash

-- | Sub-type for contest transition with auxiliary data as needed.
data ContestRedeemer

-- | Contesting snapshot refers to the current state version
ContestCurrent :: [Signature] -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | Contesting snapshot refers to the previous state version
ContestOutdated :: [Signature] -> Hash -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | UTxO which was already decommitted ηω
[$sel:alreadyDecommittedUTxOHash:ContestCurrent] :: ContestRedeemer -> Hash

-- | Sub-type for decrement transition with auxiliary data as needed.
data DecrementRedeemer
DecrementRedeemer :: [Signature] -> SnapshotNumber -> Integer -> DecrementRedeemer

-- | Spec: ξ
[$sel:signature:DecrementRedeemer] :: DecrementRedeemer -> [Signature]

-- | Spec: s
[$sel:snapshotNumber:DecrementRedeemer] :: DecrementRedeemer -> SnapshotNumber

-- | Spec: m
[$sel:numberOfDecommitOutputs:DecrementRedeemer] :: DecrementRedeemer -> Integer
data Input
CollectCom :: Input
Decrement :: DecrementRedeemer -> Input
Close :: CloseRedeemer -> Input
Contest :: ContestRedeemer -> Input
Abort :: Input
Fanout :: Integer -> Integer -> Input

-- | Spec: m
[$sel:numberOfFanoutOutputs:CollectCom] :: Input -> Integer

-- | Spec: n
[$sel:numberOfDecommitOutputs:CollectCom] :: Input -> Integer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.Input
instance GHC.Show.Show Hydra.Contract.HeadState.Input
instance GHC.Generics.Generic Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.DecrementRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.DecrementRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.DecrementRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.DecrementRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.DecrementRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.ContestRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.ContestRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.ContestRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.ContestRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.ContestRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.CloseRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.CloseRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.CloseRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.CloseRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.CloseRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.State
instance GHC.Show.Show Hydra.Contract.HeadState.State
instance GHC.Generics.Generic Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.ClosedDatum
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.ClosedDatum
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.ClosedDatum
instance GHC.Show.Show Hydra.Contract.HeadState.ClosedDatum
instance GHC.Generics.Generic Hydra.Contract.HeadState.ClosedDatum
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.OpenDatum
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.OpenDatum
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.OpenDatum
instance GHC.Show.Show Hydra.Contract.HeadState.OpenDatum
instance GHC.Generics.Generic Hydra.Contract.HeadState.OpenDatum


-- | Module for the on-chain representation of Utxo.
module Hydra.Data.Utxo
newtype Utxo
Utxo :: BuiltinByteString -> Utxo
fromByteString :: ByteString -> Utxo
toByteString :: Utxo -> ByteString
instance PlutusTx.IsData.Class.FromData Hydra.Data.Utxo.Utxo
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.Utxo.Utxo
instance PlutusTx.IsData.Class.ToData Hydra.Data.Utxo.Utxo


-- | A custom ScriptContext and TxInfo which only "decodes" the fields we
--   need.
module Hydra.ScriptContext
data TxInfo
TxInfo :: [TxInInfo] -> BuiltinData -> [TxOut] -> Value -> Value -> BuiltinData -> BuiltinData -> BuiltinData -> [PubKeyHash] -> BuiltinData -> Map DatumHash Datum -> BuiltinData -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> BuiltinData

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> BuiltinData

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> BuiltinData

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> BuiltinData

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | A table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> BuiltinData

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> BuiltinData

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ScriptHash -> TxInfo -> [(OutputDatum, Value)]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ScriptHash -> Value

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance PlutusTx.IsData.Class.ToData Hydra.ScriptContext.ScriptContext
instance PlutusTx.IsData.Class.FromData Hydra.ScriptContext.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.ScriptContext.ScriptContext
instance PlutusTx.IsData.Class.ToData Hydra.ScriptContext.TxInfo
instance PlutusTx.IsData.Class.FromData Hydra.ScriptContext.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.ScriptContext.TxInfo


-- | The validator used to collect &amp; open or abort a Head.
module Hydra.Contract.Commit
data CommitRedeemer
ViaCollectCom :: CommitRedeemer
ViaAbort :: CommitRedeemer

-- | A data type representing comitted outputs on-chain. Besides recording
--   the original <a>TxOutRef</a>, it also stores a binary representation
--   compatible between on- and off-chain code to be hashed in the
--   validators.
data Commit
Commit :: TxOutRef -> BuiltinByteString -> Commit
[input] :: Commit -> TxOutRef
[preSerializedOutput] :: Commit -> BuiltinByteString

-- | Record an off-chain <tt>TxOut</tt> as a <a>Commit</a> on-chain. NOTE:
--   Depends on the <tt>Serialise</tt> instance for Plutus' <tt>Data</tt>.
serializeCommit :: (TxIn, TxOut CtxUTxO) -> Maybe Commit

-- | Decode an on-chain <tt>SerializedTxOut</tt> back into an off-chain
--   <tt>TxOut</tt>. NOTE: Depends on the <tt>Serialise</tt> instance for
--   Plutus' <tt>Data</tt>.
deserializeCommit :: Network -> Commit -> Maybe (TxIn, TxOut CtxUTxO)
type DatumType = (Party, [Commit], CurrencySymbol)
type RedeemerType = CommitRedeemer

-- | The v_commit validator verifies that:
--   
--   <ul>
--   <li>spent in a transaction also consuming a v_head output</li>
--   <li>ST is burned if the redeemer is <a>ViaAbort</a></li>
--   <li>ST is present in the output if the redeemer is
--   <a>ViaCollectCom</a></li>
--   </ul>
validator :: DatumType -> RedeemerType -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Commit.Commit
instance GHC.Classes.Ord Hydra.Contract.Commit.Commit
instance GHC.Show.Show Hydra.Contract.Commit.Commit
instance GHC.Classes.Eq Hydra.Contract.Commit.Commit
instance PlutusTx.Eq.Eq Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Commit.CommitRedeemer


-- | The initial validator which allows participants to commit or abort.
module Hydra.Contract.Initial
data InitialRedeemer
ViaAbort :: InitialRedeemer
ViaCommit :: [TxOutRef] -> InitialRedeemer

-- | Points to the committed Utxo.
[committedRefs] :: InitialRedeemer -> [TxOutRef]
type DatumType = CurrencySymbol
type RedeemerType = InitialRedeemer

-- | The v_initial validator verifies that:
--   
--   <ul>
--   <li>spent in a transaction also consuming a v_head output</li>
--   <li>ensures the committed value is recorded correctly in the output
--   datum</li>
--   <li>ensures that the transaction was signed by the key corresponding
--   to the PubKeyHash encoded in the participation token name</li>
--   </ul>
--   
--   NOTE: It does not need to ensure that the participation token is of
--   some specific Head currency.
validator :: ScriptHash -> DatumType -> RedeemerType -> ScriptContext -> Bool
checkCommit :: ScriptHash -> CurrencySymbol -> [TxOutRef] -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Initial.InitialRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Initial.InitialRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Initial.InitialRedeemer

module Hydra.Contract.Head
type DatumType = State
type RedeemerType = Input
headValidator :: State -> Input -> ScriptContext -> Bool

-- | On-Chain verification for <a>Abort</a> transition. It verifies that:
--   
--   <ul>
--   <li>All PTs have been burnt: The right number of Head tokens with the
--   correct head id are burnt, one PT for each party and a state token
--   ST.</li>
--   <li>All committed funds have been redistributed. This is done via
--   v_commit and it only needs to ensure that we have spent all comitted
--   outputs, which follows from burning all the PTs.</li>
--   </ul>
checkAbort :: ScriptContext -> CurrencySymbol -> [Party] -> Bool

-- | On-Chain verification for <a>CollectCom</a> transition. It verifies
--   that:
--   
--   <ul>
--   <li>All participants have committed (even empty commits)</li>
--   <li>All commits are properly collected and locked into η as a hash of
--   serialized tx outputs in the same sequence as commit inputs!</li>
--   <li>The transaction is performed (i.e. signed) by one of the head
--   participants</li>
--   <li>State token (ST) is present in the output</li>
--   </ul>
checkCollectCom :: ScriptContext -> (ContestationPeriod, [Party], CurrencySymbol) -> Bool

-- | Try to find the commit datum in the input and if it is there return
--   the committed utxo
commitDatum :: TxOut -> [Commit]

-- | Verify a decrement transaction.
checkDecrement :: ScriptContext -> OpenDatum -> DecrementRedeemer -> Bool

-- | Verify a close transaction.
checkClose :: ScriptContext -> OpenDatum -> CloseRedeemer -> Bool

-- | Verify a contest transaction.
checkContest :: ScriptContext -> ClosedDatum -> ContestRedeemer -> Bool

-- | Verify a fanout transaction.
checkFanout :: ScriptContext -> ClosedDatum -> Integer -> Integer -> Bool
(&) :: a -> (a -> b) -> b
txOutAdaValue :: TxOut -> Integer
txInfoAdaFee :: TxInfo -> Integer
makeContestationDeadline :: ContestationPeriod -> ScriptContext -> POSIXTime
getHeadInput :: ScriptContext -> TxInInfo
getHeadAddress :: ScriptContext -> Address
mustNotChangeParameters :: ([Party], [Party]) -> (ContestationPeriod, ContestationPeriod) -> (CurrencySymbol, CurrencySymbol) -> Bool
mustBeSignedByParticipant :: ScriptContext -> CurrencySymbol -> Bool
findParticipationTokens :: CurrencySymbol -> Value -> [TokenName]
headOutputDatum :: ScriptContext -> Datum
getTxOutDatum :: TxOut -> Datum

-- | Hash a potentially unordered list of commits by sorting them,
--   concatenating their <a>preSerializedOutput</a> bytes and creating a
--   SHA2_256 digest over that.
--   
--   NOTE: See note from <a>hashTxOuts</a>.
hashPreSerializedCommits :: [Commit] -> BuiltinByteString

-- | Hash a pre-ordered list of transaction outputs by serializing each
--   individual <a>TxOut</a>, concatenating all bytes together and creating
--   a SHA2_256 digest over that.
--   
--   NOTE: In general, from asserting that `hash(x || y) = hash (x' || y')`
--   it is not safe to conclude that `(x,y) = (x', y')` as the same hash
--   could be obtained by moving one or more bytes from the end of
--   <tt>x</tt> to the beginning of <tt>y</tt>, but in the context of Hydra
--   validators it seems impossible to exploit this property without
--   breaking other logic or verification (eg. producing a valid and
--   meaningful <a>TxOut</a>).
hashTxOuts :: [TxOut] -> BuiltinByteString

-- | Check if <a>TxOut</a> contains the PT token.
hasPT :: CurrencySymbol -> TxOut -> Bool

-- | Verify the multi-signature of a snapshot using given constituents
--   <a>State</a>, <a>ClosedDatum</a>, <tt>number</tt>, <a>ClosedDatum</a>
--   and <tt>utxoToDecommitHash</tt>. See 'SignableRepresentation Snapshot'
--   for more details.
verifySnapshotSignature :: [Party] -> (CurrencySymbol, SnapshotVersion, SnapshotNumber, Hash, Hash) -> [Signature] -> Bool

-- | Verify individual party signature of a snapshot. See
--   'SignableRepresentation Snapshot' for more details.
verifyPartySignature :: (CurrencySymbol, SnapshotVersion, SnapshotNumber, Hash, Hash) -> Party -> Signature -> Bool
compareRef :: TxOutRef -> TxOutRef -> Ordering
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
decodeHeadOutputClosedDatum :: ScriptContext -> ClosedDatum
decodeHeadOutputOpenDatum :: ScriptContext -> OpenDatum


-- | Minting policy for a single head tokens.
module Hydra.Contract.HeadTokens
validate :: ScriptHash -> ScriptHash -> TxOutRef -> MintAction -> ScriptContext -> Bool

-- | When minting head tokens we want to make sure that:
--   
--   <ul>
--   <li>The number of minted PTs == number of participants (+1 for the ST)
--   evident from the datum.</li>
--   <li>There is single state token that is paid into v_head, which
--   ensures continuity.</li>
--   <li>PTs are distributed to v_initial</li>
--   <li>Each v_initial has the policy id as its datum</li>
--   <li>Ensure out-ref and the headId are in the datum of the first output
--   of the transaction which mints tokens.</li>
--   </ul>
validateTokensMinting :: ScriptHash -> ScriptHash -> TxOutRef -> ScriptContext -> Bool

-- | Token burning check should: * Not restrict burning on the mu_head at
--   all.
--   
--   It is ensured by the v_head validator, when tokens of a specific
--   headId may be burned.
--   
--   <a>validateTokensBurning</a> just makes sure all tokens have negative
--   quantity.
validateTokensBurning :: ScriptContext -> Bool

-- | Raw minting policy code where the <a>TxOutRef</a> is still a
--   parameter.
unappliedMintingPolicy :: CompiledCode (TxOutRef -> MintingPolicyType)

-- | Get the applied head minting policy script given a seed
--   <a>TxOutRef</a>.
mintingPolicyScript :: TxOutRef -> SerialisedScript

-- | Get the head policy id (a.k.a headId) given a seed <a>TxIn</a>.
headPolicyId :: TxIn -> PolicyId

-- | Get the applied head minting policy script given a seed <a>TxIn</a>.
mkHeadTokenScript :: TxIn -> PlutusScript


-- | The validator used to deposit and recover locked funds
module Hydra.Contract.Deposit
data DepositRedeemer

-- | Claims already deposited funds.
Claim :: DepositRedeemer

-- | Recovers m number of deposited outputs.
Recover :: Integer -> DepositRedeemer

-- | Deposit datum containing HeadId, deadline and a list of deposits.
newtype DepositDatum
DepositDatum :: (CurrencySymbol, POSIXTime, [Commit]) -> DepositDatum

-- | v_deposit validator checks
--   
--   <ul>
--   <li>Claim redeemer -&gt; more checks will be added</li>
--   <li>Recover redeemer</li>
--   <li>The deadline has been reached.</li>
--   <li>The hash of recovered outputs are matching the deposited
--   outputs.</li>
--   </ul>
validator :: DepositDatum -> DepositRedeemer -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DepositDatum -> Datum
redeemer :: DepositRedeemer -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Deposit.DepositDatum
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Deposit.DepositDatum
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Deposit.DepositDatum
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Deposit.DepositRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Deposit.DepositRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Deposit.DepositRedeemer


-- | Things related to the Hydra smart contracts / script validators.
module Hydra.Contract

-- | Information about relevant Hydra scripts.
data ScriptInfo
ScriptInfo :: ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptInfo

-- | Hash of the μHead minting script given some default parameters.
[mintingScriptHash] :: ScriptInfo -> ScriptHash

-- | Size of the μHead minting script given some default parameters.
[mintingScriptSize] :: ScriptInfo -> Int64
[initialScriptHash] :: ScriptInfo -> ScriptHash
[initialScriptSize] :: ScriptInfo -> Int64
[commitScriptHash] :: ScriptInfo -> ScriptHash
[commitScriptSize] :: ScriptInfo -> Int64
[headScriptHash] :: ScriptInfo -> ScriptHash
[headScriptSize] :: ScriptInfo -> Int64
[depositScriptHash] :: ScriptInfo -> ScriptHash
[depositScriptSize] :: ScriptInfo -> Int64

-- | Gather <a>ScriptInfo</a> from the current Hydra scripts. This is
--   useful to determine changes in between version of 'hydra-plutus'.
scriptInfo :: ScriptInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Contract.ScriptInfo
instance GHC.Generics.Generic Hydra.Contract.ScriptInfo
instance GHC.Show.Show Hydra.Contract.ScriptInfo
instance GHC.Classes.Eq Hydra.Contract.ScriptInfo
